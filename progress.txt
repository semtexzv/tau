# Progress Log

## Learnings
(Patterns discovered during implementation)

---

## Iteration 1 - US-001: Project scaffolding and dependencies
- What was done: Initialized Cargo lib project, set up all dependencies (crossterm with event-stream, unicode-width, unicode-segmentation, tokio, futures), created module structure with placeholder comments.
- Files changed: Cargo.toml, src/lib.rs, src/terminal.rs, src/utils.rs, src/component.rs, src/tui.rs, src/components/mod.rs
- Learnings for future iterations:
  - crossterm 0.28.1 resolved (0.29.0 available but PRD specifies 0.28)
  - unicode-segmentation resolved to 1.12.0 (compatible with specified 1.11)
  - All 56 dependency packages lock cleanly
  - cargo check and cargo test both pass with zero warnings
## Task self-review PASSED
---

## Iteration 2 - US-002: Terminal trait and CrosstermTerminal
- What was done: Implemented Terminal trait with 7 methods (start, stop, write, flush, size, hide_cursor, show_cursor), CrosstermTerminal using crossterm, and MockTerminal capturing writes to Vec<String>. Wrote 9 tests covering construction, writes, start/stop, cursor visibility, size, flush, and object safety.
- Files changed: src/terminal.rs, PRD.md
- Learnings for future iterations:
  - Terminal trait is object-safe — can use `Box<dyn Terminal>` (verified with test)
  - MockTerminal has public fields (writes, started, stopped, cursor_visible) for direct test assertions
  - MockTerminal.output() concatenates all writes for full output inspection
  - MockTerminal.set_size() allows simulating resize in tests
  - crossterm::terminal::size() may fail in test/CI environments — fallback to (80, 24)
  - Event reading is NOT on the trait — crossterm's EventStream used directly by TUI run loop
## Task self-review PASSED
---

## Iteration 3 - US-003: ANSI escape code utilities
- What was done: Verified existing implementation of strip_ansi and extract_ansi_code in src/utils.rs. All acceptance criteria already met — functions correctly handle CSI, OSC, and APC sequences. 24 tests covering normal paths, edge cases (unterminated sequences, bare ESC, out of bounds), and Unicode. Marked PRD criteria complete and committed.
- Files changed: PRD.md (acceptance criteria marked [x])
- Learnings for future iterations:
  - utils.rs already had full implementation from a prior session — always check existing code before writing new
  - extract_ansi_code works on byte offsets, not char offsets — callers must pass byte positions
  - OSC and APC share extract_string_sequence helper — both terminated by BEL or ST (ESC \)
  - CSI parsing follows ECMA-48: param bytes (0x30-0x3F), intermediate bytes (0x20-0x2F), final byte (0x40-0x7E)
  - strip_ansi delegates to extract_ansi_code for consistent parsing
## Task self-review PASSED
---

## Iteration 4 - US-004: Visible width calculation
- What was done: Implemented `visible_width()` and `truncate_to_width()` in src/utils.rs. Added 18 new tests covering ASCII, ANSI, wide chars, tabs, truncation with ellipsis, ANSI preservation, wide char truncation, edge cases (empty string, max_width < ellipsis width, empty ellipsis).
- Files changed: src/utils.rs, PRD.md
- Learnings for future iterations:
  - `visible_width` strips ANSI first via `strip_ansi`, then sums per-char widths with `UnicodeWidthStr::width` on 1-char slices
  - `truncate_to_width` walks bytes manually, passing through ANSI codes and counting grapheme widths — this pattern (byte-walking with ANSI passthrough) will recur in `wrap_text_with_ansi` (US-010)
  - Tab = 3 spaces convention from pi-mono
  - `unicode_segmentation::UnicodeSegmentation` used for grapheme-aware truncation
  - `saturating_sub` handles edge case where ellipsis is wider than max_width
## Task self-review PASSED
---

## Iteration 5 - US-005: Component trait and Container
- What was done: Implemented `Component` trait (render required, handle_input + invalidate with defaults) and `Container` struct (Vec<Box<dyn Component>>, add_child, remove_child, clear, render concatenation, invalidate propagation). Wrote 11 tests including empty container, concatenation, remove/clear, default/len/is_empty, invalidation, empty child, trait defaults, and object safety.
- Files changed: src/component.rs, PRD.md
- Learnings for future iterations:
  - Component trait is object-safe — `Box<dyn Component>` works (verified with test)
  - Container.render() simply extends a Vec from each child — no special casing needed
  - Can't inspect trait object internals through Box<dyn Component> (e.g., can't check MockComponent.invalidated) — design tests around observable behavior instead
  - `Default` impl provided for Container (Clippy will want this if `new()` exists)
  - Container also exposes `len()` and `is_empty()` for convenience
## Task self-review PASSED
---

## Iteration 6 - US-006: TUI engine with full rendering
- What was done: Implemented `TUI<E>` struct generic over user event type with full rendering to terminal. Added `as_any()`/`as_any_mut()` to Terminal trait for test downcasting. TUI wraps `Box<dyn Terminal>` and root `Container`, provides `new()`, `root()`, `start()`, `stop()`, `render()`, `event_tx()`. Render builds a single String buffer wrapped in synchronized output markers, appends `\x1b[0m` reset to each line, writes+flushes once. Stores `previous_lines` and `previous_width` for future differential rendering. 20 new tests covering construction, start/stop, rendering (empty, single/multi-line, ANSI preservation, width tracking), event channel, integration.
- Files changed: src/tui.rs (full implementation), src/terminal.rs (added as_any/as_any_mut to Terminal trait + both impls), PRD.md
- Learnings for future iterations:
  - Standard Rust pattern for trait-object downcasting: add `as_any(&self) -> &dyn Any` to trait, impl returns `self`
  - `tokio::sync::mpsc::unbounded_channel()` can be created without a tokio runtime; only recv() needs async context
  - Each line gets `\x1b[0m\r\n` suffix — cursor ends on fresh line after last content, simplifying cursor math for differential rendering in US-007
  - Empty render produces just sync markers `\x1b[?2026h\x1b[?2026l` — no special casing needed
  - `event_rx` stored as `Option<UnboundedReceiver<E>>` so US-008's run loop can `.take()` it
  - MockTerminal.writes has exactly 1 entry per render() call — verified by tests
## Task self-review PASSED
---

## Iteration 7 - US-007: Differential rendering
- What was done: Rewrote TUI::render() to support differential rendering. Three render paths: first render (previous_width==0, writes all lines without clearing), width changed (clear screen + full redraw), differential (compare previous_lines vs new, only rewrite changed lines). Added `cursor_row` and `hardware_cursor_row` fields to TUI struct. When no changes detected, no output is written at all. Content shrink handled by clearing old lines with `\x1b[2K\r\n` and cursor-up to return. Updated 2 existing tests and added 13 new differential rendering tests. All 95 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, PRD.md, AGENTS.md
- Learnings for future iterations:
  - `previous_width == 0` serves as "never rendered" sentinel — no separate flag needed
  - `hardware_cursor_row` is critical for cursor math — after a partial update it may differ from `cursor_row`
  - Unified loop from `first_changed..=last_changed` handles grow/shrink/change naturally — no separate steps
  - `\x1b[2K` clears entire line but doesn't move cursor — `\r` before content ensures column 0
  - `\x1b[nA`/`\x1b[nB` with n=0 is treated as n=1 by terminals — only emit when diff > 0
  - Empty first render produces no output (not even sync markers) — cleaner than US-006's approach
  - `use std::fmt::Write` enables `write!(buffer, ...)` for formatting into String efficiently
  - Project is now a workspace: TUI code in crates/tau-tui/, tests via `cargo test -p tau-tui`
## Task self-review PASSED
---

## Iteration 8 - US-008: Async event loop with user events
- What was done: Implemented `Event<E>` enum (Key, Resize, User), `quit()`, focus management (`set_focus`/`focused`), and `TUI::run()` async event loop. Added `child_mut()` to Container for focus key forwarding. Added `crossterm_event_tx()` for injecting terminal events (testability). The run loop spawns a crossterm EventStream reader task, then `tokio::select!` on crossterm_rx and user_rx channels. Key events auto-forwarded to focused component before handler. Wrote 9 new tests (async with `#[tokio::test]`). All 109 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, crates/tau-tui/src/component.rs, PRD.md
- Learnings for future iterations:
  - crossterm `KeyCode::Esc` not `KeyCode::Escape` — always check crossterm API names
  - `Container::child_mut()` returns `Option<&mut Box<dyn Component>>` not `Option<&mut dyn Component>` — returning the inner dyn ref causes lifetime issues with `'static` trait objects
  - Crossterm EventStream works fine in tests (no real terminal): spawned reader task just blocks on stdin, test events injected via crossterm_tx channel
  - `run()` uses `.take()` on Option receivers (consumed once) — calling run() twice panics with clear message
  - `reader_handle.abort()` cleanly cancels the spawned crossterm reader on exit
  - `FnMut` closures in `run()` capture by `&mut` reference — captured vars accessible after run() returns
  - Initial `render()` called after `start()` in run() for good UX (show initial state before first event)
  - `Event<E>` derives `Debug` which requires `E: Debug` — practical constraint, all common types satisfy it
## Task self-review PASSED
---
