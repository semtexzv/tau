# Progress Log

## Learnings
(Patterns discovered during implementation)

---

## Iteration 1 - US-001: Project scaffolding and dependencies
- What was done: Initialized Cargo lib project, set up all dependencies (crossterm with event-stream, unicode-width, unicode-segmentation, tokio, futures), created module structure with placeholder comments.
- Files changed: Cargo.toml, src/lib.rs, src/terminal.rs, src/utils.rs, src/component.rs, src/tui.rs, src/components/mod.rs
- Learnings for future iterations:
  - crossterm 0.28.1 resolved (0.29.0 available but PRD specifies 0.28)
  - unicode-segmentation resolved to 1.12.0 (compatible with specified 1.11)
  - All 56 dependency packages lock cleanly
  - cargo check and cargo test both pass with zero warnings
## Task self-review PASSED
---

## Iteration 2 - US-002: Terminal trait and CrosstermTerminal
- What was done: Implemented Terminal trait with 7 methods (start, stop, write, flush, size, hide_cursor, show_cursor), CrosstermTerminal using crossterm, and MockTerminal capturing writes to Vec<String>. Wrote 9 tests covering construction, writes, start/stop, cursor visibility, size, flush, and object safety.
- Files changed: src/terminal.rs, PRD.md
- Learnings for future iterations:
  - Terminal trait is object-safe — can use `Box<dyn Terminal>` (verified with test)
  - MockTerminal has public fields (writes, started, stopped, cursor_visible) for direct test assertions
  - MockTerminal.output() concatenates all writes for full output inspection
  - MockTerminal.set_size() allows simulating resize in tests
  - crossterm::terminal::size() may fail in test/CI environments — fallback to (80, 24)
  - Event reading is NOT on the trait — crossterm's EventStream used directly by TUI run loop
## Task self-review PASSED
---

## Iteration 3 - US-003: ANSI escape code utilities
- What was done: Verified existing implementation of strip_ansi and extract_ansi_code in src/utils.rs. All acceptance criteria already met — functions correctly handle CSI, OSC, and APC sequences. 24 tests covering normal paths, edge cases (unterminated sequences, bare ESC, out of bounds), and Unicode. Marked PRD criteria complete and committed.
- Files changed: PRD.md (acceptance criteria marked [x])
- Learnings for future iterations:
  - utils.rs already had full implementation from a prior session — always check existing code before writing new
  - extract_ansi_code works on byte offsets, not char offsets — callers must pass byte positions
  - OSC and APC share extract_string_sequence helper — both terminated by BEL or ST (ESC \)
  - CSI parsing follows ECMA-48: param bytes (0x30-0x3F), intermediate bytes (0x20-0x2F), final byte (0x40-0x7E)
  - strip_ansi delegates to extract_ansi_code for consistent parsing
## Task self-review PASSED
---

## Iteration 4 - US-004: Visible width calculation
- What was done: Implemented `visible_width()` and `truncate_to_width()` in src/utils.rs. Added 18 new tests covering ASCII, ANSI, wide chars, tabs, truncation with ellipsis, ANSI preservation, wide char truncation, edge cases (empty string, max_width < ellipsis width, empty ellipsis).
- Files changed: src/utils.rs, PRD.md
- Learnings for future iterations:
  - `visible_width` strips ANSI first via `strip_ansi`, then sums per-char widths with `UnicodeWidthStr::width` on 1-char slices
  - `truncate_to_width` walks bytes manually, passing through ANSI codes and counting grapheme widths — this pattern (byte-walking with ANSI passthrough) will recur in `wrap_text_with_ansi` (US-010)
  - Tab = 3 spaces convention from pi-mono
  - `unicode_segmentation::UnicodeSegmentation` used for grapheme-aware truncation
  - `saturating_sub` handles edge case where ellipsis is wider than max_width
## Task self-review PASSED
---

## Iteration 5 - US-005: Component trait and Container
- What was done: Implemented `Component` trait (render required, handle_input + invalidate with defaults) and `Container` struct (Vec<Box<dyn Component>>, add_child, remove_child, clear, render concatenation, invalidate propagation). Wrote 11 tests including empty container, concatenation, remove/clear, default/len/is_empty, invalidation, empty child, trait defaults, and object safety.
- Files changed: src/component.rs, PRD.md
- Learnings for future iterations:
  - Component trait is object-safe — `Box<dyn Component>` works (verified with test)
  - Container.render() simply extends a Vec from each child — no special casing needed
  - Can't inspect trait object internals through Box<dyn Component> (e.g., can't check MockComponent.invalidated) — design tests around observable behavior instead
  - `Default` impl provided for Container (Clippy will want this if `new()` exists)
  - Container also exposes `len()` and `is_empty()` for convenience
## Task self-review PASSED
---

## Iteration 6 - US-006: TUI engine with full rendering
- What was done: Implemented `TUI<E>` struct generic over user event type with full rendering to terminal. Added `as_any()`/`as_any_mut()` to Terminal trait for test downcasting. TUI wraps `Box<dyn Terminal>` and root `Container`, provides `new()`, `root()`, `start()`, `stop()`, `render()`, `event_tx()`. Render builds a single String buffer wrapped in synchronized output markers, appends `\x1b[0m` reset to each line, writes+flushes once. Stores `previous_lines` and `previous_width` for future differential rendering. 20 new tests covering construction, start/stop, rendering (empty, single/multi-line, ANSI preservation, width tracking), event channel, integration.
- Files changed: src/tui.rs (full implementation), src/terminal.rs (added as_any/as_any_mut to Terminal trait + both impls), PRD.md
- Learnings for future iterations:
  - Standard Rust pattern for trait-object downcasting: add `as_any(&self) -> &dyn Any` to trait, impl returns `self`
  - `tokio::sync::mpsc::unbounded_channel()` can be created without a tokio runtime; only recv() needs async context
  - Each line gets `\x1b[0m\r\n` suffix — cursor ends on fresh line after last content, simplifying cursor math for differential rendering in US-007
  - Empty render produces just sync markers `\x1b[?2026h\x1b[?2026l` — no special casing needed
  - `event_rx` stored as `Option<UnboundedReceiver<E>>` so US-008's run loop can `.take()` it
  - MockTerminal.writes has exactly 1 entry per render() call — verified by tests
## Task self-review PASSED
---

## Iteration 7 - US-007: Differential rendering
- What was done: Rewrote TUI::render() to support differential rendering. Three render paths: first render (previous_width==0, writes all lines without clearing), width changed (clear screen + full redraw), differential (compare previous_lines vs new, only rewrite changed lines). Added `cursor_row` and `hardware_cursor_row` fields to TUI struct. When no changes detected, no output is written at all. Content shrink handled by clearing old lines with `\x1b[2K\r\n` and cursor-up to return. Updated 2 existing tests and added 13 new differential rendering tests. All 95 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, PRD.md, AGENTS.md
- Learnings for future iterations:
  - `previous_width == 0` serves as "never rendered" sentinel — no separate flag needed
  - `hardware_cursor_row` is critical for cursor math — after a partial update it may differ from `cursor_row`
  - Unified loop from `first_changed..=last_changed` handles grow/shrink/change naturally — no separate steps
  - `\x1b[2K` clears entire line but doesn't move cursor — `\r` before content ensures column 0
  - `\x1b[nA`/`\x1b[nB` with n=0 is treated as n=1 by terminals — only emit when diff > 0
  - Empty first render produces no output (not even sync markers) — cleaner than US-006's approach
  - `use std::fmt::Write` enables `write!(buffer, ...)` for formatting into String efficiently
  - Project is now a workspace: TUI code in crates/tau-tui/, tests via `cargo test -p tau-tui`
## Task self-review PASSED
---

## Iteration 8 - US-008: Async event loop with user events
- What was done: Implemented `Event<E>` enum (Key, Resize, User), `quit()`, focus management (`set_focus`/`focused`), and `TUI::run()` async event loop. Added `child_mut()` to Container for focus key forwarding. Added `crossterm_event_tx()` for injecting terminal events (testability). The run loop spawns a crossterm EventStream reader task, then `tokio::select!` on crossterm_rx and user_rx channels. Key events auto-forwarded to focused component before handler. Wrote 9 new tests (async with `#[tokio::test]`). All 109 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, crates/tau-tui/src/component.rs, PRD.md
- Learnings for future iterations:
  - crossterm `KeyCode::Esc` not `KeyCode::Escape` — always check crossterm API names
  - `Container::child_mut()` returns `Option<&mut Box<dyn Component>>` not `Option<&mut dyn Component>` — returning the inner dyn ref causes lifetime issues with `'static` trait objects
  - Crossterm EventStream works fine in tests (no real terminal): spawned reader task just blocks on stdin, test events injected via crossterm_tx channel
  - `run()` uses `.take()` on Option receivers (consumed once) — calling run() twice panics with clear message
  - `reader_handle.abort()` cleanly cancels the spawned crossterm reader on exit
  - `FnMut` closures in `run()` capture by `&mut` reference — captured vars accessible after run() returns
  - Initial `render()` called after `start()` in run() for good UX (show initial state before first event)
  - `Event<E>` derives `Debug` which requires `E: Debug` — practical constraint, all common types satisfy it
## Task self-review PASSED
---

## Iteration 2 - US-REVIEW-PHASE1: Review foundation (US-001 through US-008)
- What was done: Full review of all 6 source files across US-001 through US-008 (terminal.rs, utils.rs, component.rs, tui.rs, components/mod.rs, lib.rs). All 109 tests pass. Evaluated simplicity, correctness, edge cases, data structures, error handling. Performed cross-task analysis.
- Files changed: PRD.md (inserted fix task US-007a), progress.txt (this entry)

### Per-task findings:
- US-001 (scaffolding): PASS. Clean. One PRD [ ] for dev-dep image is correctly deferred to US-016.
- US-002 (Terminal trait): PASS. Minimal, object-safe. as_any pattern well documented.
- US-003 (ANSI utils): PASS. Correct CSI/OSC/APC handling. Good edge case coverage.
- US-004 (visible_width): PASS. Correct. Tab=3, grapheme-aware truncation, ANSI passthrough.
- US-005 (Component/Container): PASS. Minimal trait, clean composition. child_mut returns Box correctly.
- US-006 (TUI engine): PASS. Single buffer write, sync markers, reset suffixes. Event channel pattern clean.
- US-007 (Differential rendering): BUG FOUND — see below.
- US-008 (Async event loop): PASS. Clean select!, focus forwarding, quit handling.

### Bug found — cursor position on stop():
After differential rendering, hardware_cursor_row is set to last_changed + 1, which may be in the middle of content (not at cursor_row = lines.len()). When TUI::stop() is called (e.g., at end of run()), it delegates directly to terminal.stop() without repositioning the cursor. In the scrolling model, this means the shell prompt appears in the middle of the TUI's output.

Example: 5 lines, update line 1 only → hardware_cursor_row=2, cursor_row=5. After stop(), cursor is at row 2. Shell prompt overlays lines 2-4.

Fix inserted as US-007a: TUI::stop() must move cursor from hardware_cursor_row to cursor_row before calling terminal.stop().

### Cross-task analysis:
- Component trait: Ergonomic, not fighting ownership. Only render() required.
- Terminal trait: Minimal. Event reading outside trait works cleanly.
- Differential rendering math: Correct for all three paths. Only issue is stop() cursor.
- visible_width: Not yet needed in rendering engine (components pad their own output). Will be used by Text/Box.
- Async event loop: Channel closed handled. EventStream reader aborted on exit.
- Focus management: Clean integration. Index-based focus is pragmatic.
- TUI<E> generic: E: Send + 'static only. Components unaware of E. TUI<()> works.
- No duplication found across tasks.
- Naming/style consistent throughout.
- Data flows (Terminal→TUI→Container→Component, events→channels→select→handler) are clean and unidirectional.

### Review result: ISSUES FOUND (1 bug → US-007a fix task inserted)
- Learnings for future iterations:
  - Differential rendering leaving cursor mid-content is a common bug pattern — always verify cursor position at session boundaries (start/stop)
  - The hardware_cursor_row vs cursor_row distinction is critical and easy to miss
  - Test coverage should include stop-after-differential-render scenarios
---

## Iteration 3 - US-007a: Fix cursor repositioning on TUI stop
- What was done: Fixed TUI::stop() to emit `\x1b[{n}B` cursor-down escape before calling terminal.stop() when hardware_cursor_row < cursor_row. Added 2 tests: one verifying cursor movement after differential render (5 lines, update line 1, stop moves cursor down 3), one verifying no cursor movement when already at end. All 111 tests pass.
- Files changed: crates/tau-tui/src/tui.rs (stop() fix + 2 tests), PRD.md (criteria marked [x])
- Learnings for future iterations:
  - TDD worked cleanly: wrote 2 tests first, one failed, one passed (correct by accident since stop() was a no-op), then 3-line fix made both pass
  - stop() updates hardware_cursor_row after cursor move — keeps state consistent in case stop() is called multiple times (defensive)
  - The fix is write+flush, not buffered into sync markers — stop() is a one-time terminal teardown, not a render frame
## Task self-review PASSED
---

## Iteration 4 - US-REVIEW-PHASE1: Review foundation (re-review after US-007a fix)
- What was done: Re-reviewed all 6 source files (terminal.rs, utils.rs, component.rs, tui.rs, components/mod.rs, lib.rs) after US-007a cursor fix. All 111 tests pass. Zero clippy warnings. Verified US-007a fix is clean and correct. Full cross-task analysis passed.
- Files changed: PRD.md (review task marked [x]), progress.txt (this entry)

### Per-task re-evaluation (all PASS):
- US-001 (scaffolding): Clean workspace. image dev-dep deferred to US-016.
- US-002 (Terminal trait): Minimal 7-method trait + as_any for test downcasting.
- US-003 (ANSI utils): Correct CSI/OSC/APC parsing. 24 tests.
- US-004 (visible_width): Tab=3, grapheme-aware truncation, ANSI passthrough. 18 tests.
- US-005 (Component/Container): Minimal trait. child_mut returns &mut Box correctly. 11 tests.
- US-006 (TUI engine): Single-write rendering, sync markers, reset suffixes. 20 tests.
- US-007 (Differential rendering): All three paths verified by tracing. 13 tests.
- US-007a (stop cursor fix): Clean 3-line fix with 2 tests. Verified correct.
- US-008 (Async event loop): select!, focus forwarding, channel lifecycle. 9 async tests.

### Cross-task analysis (all clean):
- Component trait: ergonomic, only render() required. No fighting with Rust ownership.
- Terminal trait: minimal, event reading outside trait works cleanly via channels.
- Differential rendering math: traced all paths (first, width-change, differential, shrink, grow-from-empty, shrink-to-empty). Correct.
- visible_width: correctly deferred—not needed in engine yet, components pad their own output.
- Event loop: channel-closed handled (else => break), reader aborted on exit.
- Focus management: index-based, key forwarded before handler. Invalid index safely returns None.
- TUI<E>: E: Send + 'static only. Components unaware of E. TUI<()> works.
- No duplication between modules. Consistent naming/style. Clean unidirectional data flows.

## Phase 1 review PASSED
- Learnings for future iterations:
  - Iterative review works: first pass found a real bug, fix was clean, second pass confirmed everything is solid
  - The hardware_cursor_row/cursor_row distinction is the most subtle part of the codebase — well documented now
  - 111 tests provide strong coverage for the foundation layer
---

## Iteration 5 - US-009: Spacer component
- What was done: Implemented Spacer component in src/components/spacer.rs. Struct with `lines: usize` field, `new(lines)`, `set_lines(n)`, `Default` (1 line), Component impl returning `vec![String::new(); lines]`. Registered in components/mod.rs with `pub use`. 6 tests covering: n lines, default, zero, set_lines, width-independence, object safety. All 117 tests pass.
- Files changed: crates/tau-tui/src/components/spacer.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md (criteria marked [x])
- Learnings for future iterations:
  - Components in `components/` dir follow pattern: mod.rs declares `pub mod X; pub use X::Type;`
  - Spacer is the simplest possible component — good reference for the Component trait contract
  - `vec![String::new(); n]` is idiomatic Rust for n copies of an empty string
## Task self-review PASSED
---

## Iteration 6 - US-010: Text component with word wrapping
- What was done: Implemented `wrap_text_with_ansi()` in utils.rs and `Text` component in components/text.rs. wrap_text_with_ansi splits on word boundaries, breaks long words char-by-char (grapheme-aware), tracks ANSI SGR state and re-applies at start of each wrapped line, preserves hard newlines. Text component wraps content with configurable padding_x/padding_y, pads each line to full width, caches rendered output via RefCell<Option<CachedRender>>. 17 wrap tests + 15 Text tests added. All 149 tests pass.
- Files changed: crates/tau-tui/src/utils.rs (wrap_text_with_ansi + SGR helpers), crates/tau-tui/src/components/text.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - SGR tracking: accumulate all non-reset SGR codes in Vec<String>, \x1b[0m clears all. Redundant codes are harmless (terminal processes them in order).
  - Break-at-space tracking: record byte position in current_line string, break_width (visible width before space), and break_sgr (SGR state at space). after_break = current_line[bp+1..] naturally includes any ANSI codes after the space.
  - Final-line push logic: use `initial_len` to distinguish "empty hard line" (push empty) from "leftover after break" (don't push empty). Avoids spurious trailing empty lines.
  - RefCell<Option<CachedRender>> for caching in render(&self) — safe because Component doesn't require Send and TUI runs on single thread.
  - Text padding: left_pad + content + right_pad fills to full width. inner_width = width - 2*padding_x for wrapping.
  - Empty text or inner_width=0 → return empty vec (no padding lines either).
## Task self-review PASSED
---

## Iteration 7 - US-011: Box component
- What was done: Implemented BoxComponent in src/components/box_component.rs. Holds Vec<Box<dyn Component>> children with configurable padding_x, padding_y, and optional background color. Renders children at inner width (width - 2*padding_x), wraps each line with left padding + right padding to full width, applies background ANSI code if set (bg_start + content + bg_end), adds padding_y empty lines above and below. 12 tests covering: empty box, text child with padding, background on all lines, no-bg no-ANSI, inner width rendering, multiple children, remove/clear, invalidate propagation, object safety, empty children, padding_y only. All 161 tests pass.
- Files changed: crates/tau-tui/src/components/box_component.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - BoxComponent follows same container pattern as Container (add_child/remove_child/clear) but with render decoration
  - Background applied as bg_start + padded_line + \x1b[0m — reset at end of each line prevents bleed
  - When bg is None, bg_start="" and bg_end="" → no ANSI overhead in output
  - Empty children → empty result (no padding lines emitted), matching Text's "no content = no output" convention
  - `saturating_sub` for inner_width handles case where padding exceeds width
## Task self-review PASSED
---

## Iteration 8 - US-012: Input component
- What was done: Implemented Input component in src/components/input.rs. Single-line text input with "> " prompt, inverse-video cursor, full editing keybindings (insert, backspace, delete, word-delete, ctrl-u, ctrl-k), cursor movement (left, right, home, end, ctrl-left word-back, ctrl-right word-forward), horizontal scrolling via compute_scroll pure function, on_submit/on_escape callbacks, value()/set_value() API, focused flag. scroll_offset uses Cell<usize> for interior mutability in render(&self). 28 tests covering all editing ops, cursor movement, scrolling, callbacks, rendering. All 189 tests pass.
- Files changed: crates/tau-tui/src/components/input.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - Cell<usize> (not RefCell) is sufficient for scroll_offset since usize is Copy — simpler than RefCell
  - compute_scroll is a pure function: takes (cursor, current_offset, available) → new_offset. Separated from render logic for testability.
  - Scroll offset must be persisted between renders for smooth scrolling — without persistence, moving cursor left causes the view to jump back to start
  - render(&self) can't mutate fields directly — use Cell/RefCell for state that needs updating during render
  - Cursor operates on char indices, conversion to byte positions via char_to_byte helper
  - Word movement: skip spaces then skip word-chars (or vice versa) — simple two-phase algorithm
  - handle_input doesn't know the width, so scroll adjustment is deferred to render() which does know
  - \x1b[7m / \x1b[27m for inverse video cursor — 7m enables, 27m disables (not 0m which would reset everything)
  - Callbacks use `Option<Box<dyn FnMut>>` — clone the value before calling to avoid borrow issues
## Task self-review PASSED
---

## Iteration 9 - US-013: SelectList component
- What was done: Implemented SelectList component in src/components/select_list.rs. Selectable list with arrow-key navigation, wrapping, scrolling, filtering, and callbacks. SelectItem struct with value/label/description. Visible window rendering with "→ " prefix and bold/inverse styling for selected item. Scroll indicator "(N/M)" when list exceeds max_visible. set_filter() for case-insensitive prefix matching. 31 tests covering rendering, selection movement, wrapping, scrolling, filtering, callbacks, edge cases, object safety. All 220 tests pass.
- Files changed: crates/tau-tui/src/components/select_list.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - SelectList uses `filtered_indices: Vec<usize>` as indirection layer — all selection/scroll operates on filtered indices, not raw items. Clean separation.
  - `selected` and `scroll_offset` are indices into filtered_indices, not into items — this makes filter changes simple (just reset both to 0).
  - Wrapping with modular arithmetic: `(selected + 1) % count` for down, `count - 1` for up-from-0.
  - `ensure_visible()` adjusts scroll_offset after each move — simple 2-condition check.
  - Bold+inverse combined: `\x1b[1;7m` for selected item — single SGR sequence with both attributes.
  - Selected line gets `\x1b[0m` at end (after padding) so background extends to full width. Unselected lines have no ANSI at all.
  - "(no items)" placeholder when filtered_indices is empty — consistent UX for empty states.
  - Scroll indicator right-aligned: pad with spaces before indicator text.
  - Callbacks clone the SelectItem before calling to avoid borrow issues with `&mut self` (same pattern as Input).
## Task self-review PASSED
---

## Iteration 10 - US-014: Overlay system
- What was done: Implemented overlay system with compositing, focus save/restore, and overlay stack. Added `Anchor` enum (Center, TopLeft, TopRight, BottomLeft, BottomRight), `OverlayOptions` struct (width, max_height, anchor, offset_x, offset_y), `OverlayHandle` (hide/set_hidden via `Rc<Cell<bool>>`), `OverlayEntry` (internal), and TUI methods (show_overlay, hide_overlay, has_overlay). Compositing happens in render() between base rendering and differential comparison — overlays are spliced into base lines at calculated positions. Added `slice_from_column` to utils.rs with SGR state tracking. Made `is_sgr`, `update_sgr_state`, `sgr_prefix` pub(crate). Modified run() key forwarding to check overlays first (topmost visible gets input). 32 new tests (8 slice_from_column, 5 splice, 4 position, 6 TUI methods, 3 compositing, 3 focus, 3 async input forwarding). All 252 tests pass.
- Files changed: crates/tau-tui/src/utils.rs (slice_from_column + SGR visibility), crates/tau-tui/src/tui.rs (overlay types + methods + compositing + tests), PRD.md
- Learnings for future iterations:
  - `Rc<Cell<bool>>` works well for shared visibility state in single-threaded TUI — TUI is already !Send due to Box<dyn Terminal>
  - Overlay compositing inserts between base rendering and differential comparison — differential rendering then naturally handles overlay changes
  - `splice_overlay_into_line` uses ANSI resets (\x1b[0m) as boundaries between base/overlay/base sections, and re-applies base SGR state for the "after" portion via `slice_from_column`
  - `truncate_to_width(s, col, "")` is the "slice before" operation — existing utility, no new code needed
  - `calculate_overlay_position` is a pure function with `saturating_sub` for all anchor types and `.max(0)` clamping for negative offsets
  - Base content is extended with empty strings if overlay position goes beyond — clean handling without special cases
  - Overlay stack uses Vec<OverlayEntry> with .pop() for LIFO ordering — topmost is last element, `iter_mut().rev()` for finding topmost visible
  - Focus save/restore: each overlay entry saves `self.focused` at show time, restores on hide — nested overlays work correctly
  - Key forwarding: overlays checked first via reverse iteration, falls through to focused component only if no visible overlays
## Task self-review PASSED
---

## Iteration 1 - US-REVIEW-PHASE2: Review components and overlays (US-009 through US-014)
- What was done: Full review of 7 source files across US-009 through US-014 (spacer.rs, text.rs, box_component.rs, input.rs, select_list.rs, tui.rs overlay system, utils.rs SGR/slice additions). All 252 tests pass. Zero clippy errors (6 warnings: 2 type_complexity, 4 repeat_n).

### Per-task findings:
- US-009 (Spacer): PASS. Trivially correct. 6 tests.
- US-010 (Text): PASS. Word wrapping with ANSI SGR tracking is correct. RefCell cache pattern appropriate. Padding_y lines are empty strings (intentional — vertical spacing only). 32 tests.
- US-011 (BoxComponent): PASS. Clean container pattern with bg color decoration. All lines padded to full width. Empty children → empty result. 12 tests.
- US-012 (Input): BUG FOUND — see below. Editing/keybindings/callbacks all correct. 28 tests (only ASCII).
- US-013 (SelectList): PASS. Clean filtered_indices indirection. All lines padded. Wrapping/scrolling correct. 31 tests.
- US-014 (Overlay): PASS. Compositing via splice_overlay_into_line is correct. SGR state tracking across splice boundaries works. Focus save/restore with nested overlays correct. Key forwarding to topmost visible overlay correct. 32 tests.

### Bug found — Input cursor math with wide characters (US-012):
Two related issues in `compute_scroll()` and render padding:

1. **compute_scroll() conflates char indices with column widths**: `available` is in columns (e.g., 8 for terminal width 10), but `cursor` and `offset` are char indices. With wide chars (2 cols each), scrolling by 1 char position only removes 2 columns but the algorithm treats it as removing 1 column-equivalent.

   Example: buffer = "你好世界测试编程代码" (10 chars, 20 cols), width=12, available=10.
   compute_scroll(cursor=10, offset=0, available=10): returns offset=1. But chars[1..10] = "好世界测试编程代码" = 18 visible columns in 10 available columns → massive overflow.

2. **Render padding uses char count instead of column width**: `content_width = PROMPT_WIDTH + vis_len.max(cursor_in_view + 1)` where `cursor_in_view + 1` counts chars, not columns. With cursor at end of "你好" (vis_len=4, cursor_in_view=2), content_width = 2+max(4,3) = 6, but actual visible content is 2+4+1=7 → padding is 1 column short → line overflows terminal width.

Fix inserted as US-012a: Input scroll and padding must operate consistently in column widths.

### Cross-task analysis:
- Component trait API: Consistent across all components. render(&self) works with interior mutability (RefCell/Cell) where needed.
- TUI<E> generic: Does NOT leak into Component trait. Components are E-agnostic. ✓
- Full-width padding: All components pad content lines to full width (Spacer uses empty strings for spacing, which is intentional). ✓
- Overlay compositing: splice handles wide chars at boundaries via truncate_to_width padding. ✓
- Overlay focus: save/restore with nested overlays tested and correct. ✓
- SelectList+overlay integration: Not explicitly tested but component model ensures it works — SelectList is a normal Component. ✓
- visible_width: Used correctly in Text, BoxComponent, Input, SelectList, overlay splice. ✓
- Duplicated padding patterns: Each component has slightly different padding logic (some have bg, some have left-pad). Not worth extracting a common helper.
- Clippy warnings: 6 total (4x repeat_n modernization in SelectList, 2x type_complexity for callback types). Style only, not correctness.

### Review result: ISSUES FOUND (1 bug → US-012a fix task inserted)
- Learnings for future iterations:
  - When a component tracks cursor position in char indices but renders in column widths, ALL math must be consistent. This is the same class of bug as hardware_cursor_row vs cursor_row in US-007.
  - Input scroll tests only use ASCII — wide char scroll tests would have caught this immediately.
  - The review criteria "Verify Input cursor math is correct with Unicode" is the right thing to check.
  - Overlay compositing is surprisingly correct with ANSI codes — the slice_from_column + splice pattern handles edge cases well through design (using resets as boundaries).
  - RefCell for caching in render(&self) is the standard pattern — all components that need it use it correctly.
---

## Iteration 2 - US-012a: Fix Input horizontal scrolling and padding for wide characters
- What was done: Fixed two bugs in Input component where compute_scroll and render conflated char indices with column widths. Added `char_col_width()` and `chars_col_width()` helpers using `unicode_width::UnicodeWidthChar`. Rewrote `compute_scroll()` to accept `&[char]` and loop using column-width comparisons. Rewrote render's visible_end to walk chars summing column widths. Fixed padding to use `vis_cols` + `cursor_extra` (1 for space cursor at end, 0 when cursor in text). Added 6 wide character tests. All 258 tests pass.
- Files changed: crates/tau-tui/src/components/input.rs, PRD.md
- Learnings for future iterations:
  - When a component mixes char indices with column widths, ALL comparisons must be consistent — this is the same class of bug as hardware_cursor_row vs cursor_row
  - `compute_scroll` is still O(n) per render in worst case (incrementing offset one char at a time) — acceptable for typical terminal input but could be optimized with backward walk if needed
  - `visible_width` import moved from module scope to test-only since render now computes vis_cols directly during the visible_end walk — cleaner than calling visible_width on the sliced string
  - `char_col_width` uses `.unwrap_or(0)` for control chars — defensive, since Input only accepts printable chars from KeyCode::Char
  - For cursor-at-end case: vis_cols already <= available-1 (guaranteed by compute_scroll), so adding 1 for space cursor never overflows available columns
  - Wide chars at boundary: if a wide char doesn't fit, visible_end stops before it, leaving unused columns that padding fills
## Task self-review PASSED
---

## Iteration 3 - US-REVIEW-PHASE2: Re-review components and overlays (post US-012a fix)
- What was done: Re-reviewed all 7 source files across US-009 through US-014 (spacer.rs, text.rs, box_component.rs, input.rs, select_list.rs, tui.rs overlay system, utils.rs SGR/slice additions) after US-012a fix. All 258 tests pass. 6 clippy warnings (style only: 2 type_complexity, 4 repeat_n). Zero errors.
- Files changed: PRD.md (review task marked [x]), progress.txt (this entry)

### Per-task re-evaluation (all PASS):
- US-009 (Spacer): Trivially correct. vec![String::new(); lines]. 6 tests.
- US-010 (Text): Word wrapping with SGR tracking correct. RefCell cache appropriate. Padding fills to full width. 32 tests.
- US-011 (BoxComponent): Clean container+decoration. bg applied with reset suffix. Empty children → empty. 12 tests.
- US-012 + US-012a (Input + fix): Traced critical bug case "你好世界测试编程代码" at width 12 — compute_scroll now correctly uses chars_col_width for column comparisons (offset=6, vis_cols=8, content_cols=11, pad=1, total=12 ✓). Also traced cursor-in-middle and cursor-at-start cases. All correct. 34 tests (6 wide-char tests from US-012a).
- US-013 (SelectList): Clean filtered_indices indirection. Wrapping, scrolling, filtering all correct. Lines padded to full width. "→ " prefix is 2 visible columns, matching "  " for unselected. 31 tests.
- US-014 (Overlay): splice_overlay_into_line with ANSI resets as boundaries is correct. Traced case with \x1b[31m active base → reset before overlay → re-apply SGR after overlay ✓. Focus save/restore is stack-based LIFO. Key forwarding to topmost visible overlay correct. Rc<Cell<bool>> appropriate since TUI is !Send. 32 tests.

### Cross-task analysis (all clean):
- Component trait API: Consistent render(&self, width) across all components. Interior mutability (RefCell/Cell) only where needed.
- TUI<E> generic: Does NOT leak into Component. Components are E-agnostic. TUI<()> works.
- Full-width padding: All visible-content components pad to full width. Spacer returns empty strings (vertical spacing only).
- visible_width: Used correctly in Text, BoxComponent, SelectList, overlay splice. Input uses char_col_width directly (appropriate for char-level walking).
- Overlay compositing: splice handles ANSI codes at boundaries via truncate_to_width + slice_from_column. SGR state re-applied for "after" portion.
- Overlay focus: Stack-based save/restore with nested overlays verified and correct.
- SelectList + overlay integration: Works through component model — no special integration needed.
- No duplicated patterns worth extracting: Each component's padding logic differs (bg, prompt, prefix, padding_x/y).
- Naming/style: Consistent snake_case, module structure, test organization throughout.
- Data flows: Components render independently, Container concatenates, overlay composites onto base. Clean, unidirectional.
- Clippy: 6 style-only warnings (type_complexity for callback types, repeat_n modernization). No correctness issues.

## Phase 2 review PASSED
- Learnings for future iterations:
  - Iterative review confirmed: first pass found wide-char bug in US-012, fix in US-012a was clean and correct, re-review confirms everything is solid
  - The char-index vs column-width confusion is a recurring bug class (also seen in US-007 as hardware_cursor_row vs cursor_row) — always verify width arithmetic is consistent
  - 258 tests provide strong coverage for the component and overlay layers
  - The overlay splice pattern (reset boundaries + SGR re-application) is elegant and handles edge cases through design, not special-case code
  - compute_scroll's O(n) loop is acceptable for terminal input — could be optimized later if needed
---

## Iteration 4 - US-015: Example application with async user events
- What was done: Created `crates/tau-tui/examples/demo.rs` — a working demo app demonstrating all tau-tui components and async user events. Uses `#[tokio::main(flavor = "current_thread")]` (will be migrated to `tau_iface::block_on` in US-RT-006).
- Files changed: crates/tau-tui/examples/demo.rs (new), PRD.md (criteria marked [x])
- Features demonstrated:
  - Text with styled ANSI content (bold+cyan header)
  - BoxComponent with dark background containing a live counter
  - Input that echoes typed text via on_submit callback
  - Async user events: std::thread sends DemoEvent::Tick every second via event_tx
  - SelectList overlay triggered by Ctrl+P (7 language items, on_select updates echo)
  - Focus switching: Input normally focused, overlay gets input when shown
  - Quit with Ctrl+C (always) or Escape (when no overlay)
- Learnings for future iterations:
  - Shared state via Rc<Cell>/Rc<RefCell> is the idiomatic pattern for dynamic components in single-threaded TUI — custom components read from shared state on each render()
  - Component trait has no as_any() for downcasting, so you can't modify components after adding them to a Container — must use shared state or callbacks set before adding
  - std::thread::spawn + std::thread::sleep is simpler than tokio::spawn + tokio::time::sleep for timer — no extra tokio features needed, and UnboundedSender is Send+Sync
  - #[tokio::main(flavor = "current_thread")] needed since workspace tokio only has "rt" feature, not "rt-multi-thread"
  - SelectList overlay interaction pattern: on_select callback fires on Enter (key forwarded to overlay first), then handler sees Enter and calls hide_overlay() — clean two-phase coordination
  - Input's on_submit callback must be set before adding to container (can't access afterward without downcast)
## Task self-review PASSED
---

## Iteration 5 - US-016: GIF-to-ANSI load test
- What was done: Created `crates/tau-tui/examples/loadtest.rs` — a load test that plays animated GIFs as ANSI-colored half-block art through the TUI, measuring differential rendering performance. Added `image = "0.25"` as dev-dependency. Also marked the deferred US-001 dev-dep criterion.
- Files changed: crates/tau-tui/examples/loadtest.rs (new), crates/tau-tui/Cargo.toml (image dev-dep), PRD.md (criteria marked [x])
- Features implemented:
  - GIF-to-ANSI conversion: decode RGBA frames, scale to terminal dimensions (aspect-aware, 2:1 cell ratio), convert pixel pairs to `▀` half-block chars with truecolor ANSI
  - Pre-renders all frames at startup (decoding not in render hot path)
  - FrameComponent reads current frame index from Rc<Cell<usize>>, renders pre-computed ANSI lines
  - TimingTerminal wraps CrosstermTerminal, measures write→flush duration and byte count per render via Rc<RefCell<PerfStats>>
  - StatsComponent overlay (top-right, yellow bg) shows live FPS, avg frame time, avg bytes/frame
  - Playback thread sends Frame(usize) events at GIF's native delay (30fps fallback for zero-delay frames)
  - On exit: prints summary to stderr (total frames, avg FPS, avg/p95/max frame time, avg bytes/frame)
  - CLI argument for GIF path, error handling for file/decode failures
  - Quit with Ctrl+C or Escape
- Learnings for future iterations:
  - TimingTerminal wrapper is a clean pattern for measuring render performance — intercepts at write/flush level, shares stats via Rc<RefCell>
  - Rc<Vec<PreRenderedFrame>> can't cross thread boundaries — extract delays as Vec<Duration> for the playback thread
  - `image::AnimationDecoder::into_frames()` yields fully-composited RGBA frames (handles GIF disposal methods internally) — no manual compositing needed
  - `frame.delay().into()` converts to std::time::Duration; some GIFs have 0 delay, need fallback
  - Half-block `▀` technique: foreground = top pixel, background = bottom pixel, packs 2 vertical pixels per cell — standard ANSI art approach
  - Nearest-neighbor scaling via `(px / scale).floor()` is fast and sufficient for terminal art
  - Stats overlay uses Anchor::TopRight which is already supported by the overlay system
## Task self-review PASSED
---

## Iteration 6 - US-RT-001: tau-rt cdylib with reactor and executor
- What was done: Created `crates/tau-rt/` — a cdylib-only crate implementing the shared async runtime. Reactor owns the OS poller (via `polling` crate) and a timer heap. Executor manages a single-threaded task queue via `ConcurrentQueue<Runnable>`. All 11 C ABI functions exported via `#[no_mangle] extern "C"`. 11 unit tests including DV-1 verification (counter increment + 50ms timer test).
- Files changed: crates/tau-rt/Cargo.toml (new), crates/tau-rt/src/lib.rs (new), crates/tau-rt/src/reactor.rs (new), crates/tau-rt/src/executor.rs (new), crates/tau-rt/src/ffi.rs (new), PRD.md, AGENTS.md
- Learnings for future iterations:
  - `async_task::spawn_local` panics when Runnables are run/dropped on different threads — must use `async_task::spawn` instead for global executor (FfiFuture is Send anyway)
  - Global executor tests need `Mutex<()>` serialization guard + queue drain at test start — the ConcurrentQueue is shared across parallel test threads
  - `unsafe impl Sync for Reactor` was UNNECESSARY — Reactor auto-derives Sync because all fields are Sync (Poller) or wrapped in Mutex (which only needs T: Send)
  - `Events` from polling is `Send` but `!Sync` (via `PhantomData<Cell<()>>`), but `Mutex<Events>` is `Sync` because Mutex only requires `T: Send`
  - IO sources lazily registered with OS poller: `io_register` only adds to slab, first `io_poll_readable/writable` calls `Poller::add`. This avoids platform-specific issues with `Event::none` registration
  - `FfiContext::with_context()` is an inherent method, NOT from the `ContextExt` trait — don't import `ContextExt`
  - In polling 3, `Event` has public fields (key, readable, writable) and constructors like `Event::new(key, readable, writable)`
  - `Poller::add` takes `impl AsRawSource` (accepts raw fd directly on Unix), while `modify`/`delete` take `impl AsSource` (needs `BorrowedFd`)
  - `events.clear()` before `poller.wait()` is needed — wait() appends to the buffer, doesn't replace
  - Timer dual data structure (BTreeMap + HashMap) is essential: BTreeMap for ordered expiry scan, HashMap for O(1) handle→deadline lookup
  - cdylib crate-type doesn't prevent `cargo test` — the test harness compiles the crate differently than the library output
## Task self-review PASSED
---

## Iteration 7 - US-RT-002: tau-iface safe wrapper crate
- What was done: Created `crates/tau-iface/` — a pure-declaration crate providing safe Rust wrappers around the tau-rt C ABI. No dependency on tau-rt; linked at load time via `#[link(name = "tau_rt")]`. Added `libc = "0.2"` for raw socket operations. All 11 FFI declarations mirror tau-rt exports exactly. 6 modules: ffi.rs, async_fd.rs, timer.rs, tcp.rs, udp.rs, lib.rs. 4 unit tests for socket address conversion (roundtrip v4, roundtrip v6, specific v4, unknown family error). Zero clippy warnings. `cargo check -p tau-iface` passes cleanly.
- Files changed: crates/tau-iface/Cargo.toml (new), crates/tau-iface/src/lib.rs (new), crates/tau-iface/src/ffi.rs (new), crates/tau-iface/src/async_fd.rs (new), crates/tau-iface/src/timer.rs (new), crates/tau-iface/src/tcp.rs (new), crates/tau-iface/src/udp.rs (new), PRD.md
- Learnings for future iterations:
  - `#[link(name = "tau_rt")]` extern block only affects linking, not `cargo check` — so type-checking works without libtau_rt.dylib present
  - `async_ffi::ContextExt` trait provides `with_ffi_context()` on `std::task::Context` — this is how safe wrappers bridge the FFI gap: `cx.with_ffi_context(|ffi_cx| unsafe { ffi_fn(handle, ffi_cx as *mut _) })`
  - `async_ffi::FutureExt::into_ffi()` wraps a `Future + Send + 'static` into `FfiFuture<T>` with one heap allocation
  - AsyncFd does NOT own the fd — it only manages reactor registration. TcpStream/TcpListener/UdpSocket use OwnedFd for fd lifecycle.
  - Drop ordering matters: struct fields drop in declaration order. `async_fd` declared before `fd` ensures reactor deregistration happens before fd close.
  - Socket address conversion: `u32::from_ne_bytes(octets)` correctly preserves network byte order in memory layout on both LE and BE platforms
  - macOS has `sin_len`/`sin6_len` fields in sockaddr structures — use `#[cfg(target_os = "macos")]` to set them
  - macOS doesn't have `SOCK_NONBLOCK` flag — use `fcntl(F_SETFL, O_NONBLOCK)` instead
  - `react(None)` maps to `u64::MAX` ms timeout in the C ABI — effectively infinite (584M years)
  - `libc` crate needed for TCP/UDP implementations (raw socket, connect, recv, send, etc.) — added as additional dep beyond what PRD listed
  - `cargo test -p tau-iface` requires `LIBRARY_PATH=target/debug` to find libtau_rt.dylib at link time
## Task self-review PASSED
---
