# Progress Log

## Learnings
(Patterns discovered during implementation)

---

## Iteration 1 - US-001: Project scaffolding and dependencies
- What was done: Initialized Cargo lib project, set up all dependencies (crossterm with event-stream, unicode-width, unicode-segmentation, tokio, futures), created module structure with placeholder comments.
- Files changed: Cargo.toml, src/lib.rs, src/terminal.rs, src/utils.rs, src/component.rs, src/tui.rs, src/components/mod.rs
- Learnings for future iterations:
  - crossterm 0.28.1 resolved (0.29.0 available but PRD specifies 0.28)
  - unicode-segmentation resolved to 1.12.0 (compatible with specified 1.11)
  - All 56 dependency packages lock cleanly
  - cargo check and cargo test both pass with zero warnings
## Task self-review PASSED
---

## Iteration 2 - US-002: Terminal trait and CrosstermTerminal
- What was done: Implemented Terminal trait with 7 methods (start, stop, write, flush, size, hide_cursor, show_cursor), CrosstermTerminal using crossterm, and MockTerminal capturing writes to Vec<String>. Wrote 9 tests covering construction, writes, start/stop, cursor visibility, size, flush, and object safety.
- Files changed: src/terminal.rs, PRD.md
- Learnings for future iterations:
  - Terminal trait is object-safe — can use `Box<dyn Terminal>` (verified with test)
  - MockTerminal has public fields (writes, started, stopped, cursor_visible) for direct test assertions
  - MockTerminal.output() concatenates all writes for full output inspection
  - MockTerminal.set_size() allows simulating resize in tests
  - crossterm::terminal::size() may fail in test/CI environments — fallback to (80, 24)
  - Event reading is NOT on the trait — crossterm's EventStream used directly by TUI run loop
## Task self-review PASSED
---

## Iteration 3 - US-003: ANSI escape code utilities
- What was done: Verified existing implementation of strip_ansi and extract_ansi_code in src/utils.rs. All acceptance criteria already met — functions correctly handle CSI, OSC, and APC sequences. 24 tests covering normal paths, edge cases (unterminated sequences, bare ESC, out of bounds), and Unicode. Marked PRD criteria complete and committed.
- Files changed: PRD.md (acceptance criteria marked [x])
- Learnings for future iterations:
  - utils.rs already had full implementation from a prior session — always check existing code before writing new
  - extract_ansi_code works on byte offsets, not char offsets — callers must pass byte positions
  - OSC and APC share extract_string_sequence helper — both terminated by BEL or ST (ESC \)
  - CSI parsing follows ECMA-48: param bytes (0x30-0x3F), intermediate bytes (0x20-0x2F), final byte (0x40-0x7E)
  - strip_ansi delegates to extract_ansi_code for consistent parsing
## Task self-review PASSED
---

## Iteration 4 - US-004: Visible width calculation
- What was done: Implemented `visible_width()` and `truncate_to_width()` in src/utils.rs. Added 18 new tests covering ASCII, ANSI, wide chars, tabs, truncation with ellipsis, ANSI preservation, wide char truncation, edge cases (empty string, max_width < ellipsis width, empty ellipsis).
- Files changed: src/utils.rs, PRD.md
- Learnings for future iterations:
  - `visible_width` strips ANSI first via `strip_ansi`, then sums per-char widths with `UnicodeWidthStr::width` on 1-char slices
  - `truncate_to_width` walks bytes manually, passing through ANSI codes and counting grapheme widths — this pattern (byte-walking with ANSI passthrough) will recur in `wrap_text_with_ansi` (US-010)
  - Tab = 3 spaces convention from pi-mono
  - `unicode_segmentation::UnicodeSegmentation` used for grapheme-aware truncation
  - `saturating_sub` handles edge case where ellipsis is wider than max_width
## Task self-review PASSED
---

## Iteration 5 - US-005: Component trait and Container
- What was done: Implemented `Component` trait (render required, handle_input + invalidate with defaults) and `Container` struct (Vec<Box<dyn Component>>, add_child, remove_child, clear, render concatenation, invalidate propagation). Wrote 11 tests including empty container, concatenation, remove/clear, default/len/is_empty, invalidation, empty child, trait defaults, and object safety.
- Files changed: src/component.rs, PRD.md
- Learnings for future iterations:
  - Component trait is object-safe — `Box<dyn Component>` works (verified with test)
  - Container.render() simply extends a Vec from each child — no special casing needed
  - Can't inspect trait object internals through Box<dyn Component> (e.g., can't check MockComponent.invalidated) — design tests around observable behavior instead
  - `Default` impl provided for Container (Clippy will want this if `new()` exists)
  - Container also exposes `len()` and `is_empty()` for convenience
## Task self-review PASSED
---

## Iteration 6 - US-006: TUI engine with full rendering
- What was done: Implemented `TUI<E>` struct generic over user event type with full rendering to terminal. Added `as_any()`/`as_any_mut()` to Terminal trait for test downcasting. TUI wraps `Box<dyn Terminal>` and root `Container`, provides `new()`, `root()`, `start()`, `stop()`, `render()`, `event_tx()`. Render builds a single String buffer wrapped in synchronized output markers, appends `\x1b[0m` reset to each line, writes+flushes once. Stores `previous_lines` and `previous_width` for future differential rendering. 20 new tests covering construction, start/stop, rendering (empty, single/multi-line, ANSI preservation, width tracking), event channel, integration.
- Files changed: src/tui.rs (full implementation), src/terminal.rs (added as_any/as_any_mut to Terminal trait + both impls), PRD.md
- Learnings for future iterations:
  - Standard Rust pattern for trait-object downcasting: add `as_any(&self) -> &dyn Any` to trait, impl returns `self`
  - `tokio::sync::mpsc::unbounded_channel()` can be created without a tokio runtime; only recv() needs async context
  - Each line gets `\x1b[0m\r\n` suffix — cursor ends on fresh line after last content, simplifying cursor math for differential rendering in US-007
  - Empty render produces just sync markers `\x1b[?2026h\x1b[?2026l` — no special casing needed
  - `event_rx` stored as `Option<UnboundedReceiver<E>>` so US-008's run loop can `.take()` it
  - MockTerminal.writes has exactly 1 entry per render() call — verified by tests
## Task self-review PASSED
---

## Iteration 7 - US-007: Differential rendering
- What was done: Rewrote TUI::render() to support differential rendering. Three render paths: first render (previous_width==0, writes all lines without clearing), width changed (clear screen + full redraw), differential (compare previous_lines vs new, only rewrite changed lines). Added `cursor_row` and `hardware_cursor_row` fields to TUI struct. When no changes detected, no output is written at all. Content shrink handled by clearing old lines with `\x1b[2K\r\n` and cursor-up to return. Updated 2 existing tests and added 13 new differential rendering tests. All 95 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, PRD.md, AGENTS.md
- Learnings for future iterations:
  - `previous_width == 0` serves as "never rendered" sentinel — no separate flag needed
  - `hardware_cursor_row` is critical for cursor math — after a partial update it may differ from `cursor_row`
  - Unified loop from `first_changed..=last_changed` handles grow/shrink/change naturally — no separate steps
  - `\x1b[2K` clears entire line but doesn't move cursor — `\r` before content ensures column 0
  - `\x1b[nA`/`\x1b[nB` with n=0 is treated as n=1 by terminals — only emit when diff > 0
  - Empty first render produces no output (not even sync markers) — cleaner than US-006's approach
  - `use std::fmt::Write` enables `write!(buffer, ...)` for formatting into String efficiently
  - Project is now a workspace: TUI code in crates/tau-tui/, tests via `cargo test -p tau-tui`
## Task self-review PASSED
---

## Iteration 8 - US-008: Async event loop with user events
- What was done: Implemented `Event<E>` enum (Key, Resize, User), `quit()`, focus management (`set_focus`/`focused`), and `TUI::run()` async event loop. Added `child_mut()` to Container for focus key forwarding. Added `crossterm_event_tx()` for injecting terminal events (testability). The run loop spawns a crossterm EventStream reader task, then `tokio::select!` on crossterm_rx and user_rx channels. Key events auto-forwarded to focused component before handler. Wrote 9 new tests (async with `#[tokio::test]`). All 109 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, crates/tau-tui/src/component.rs, PRD.md
- Learnings for future iterations:
  - crossterm `KeyCode::Esc` not `KeyCode::Escape` — always check crossterm API names
  - `Container::child_mut()` returns `Option<&mut Box<dyn Component>>` not `Option<&mut dyn Component>` — returning the inner dyn ref causes lifetime issues with `'static` trait objects
  - Crossterm EventStream works fine in tests (no real terminal): spawned reader task just blocks on stdin, test events injected via crossterm_tx channel
  - `run()` uses `.take()` on Option receivers (consumed once) — calling run() twice panics with clear message
  - `reader_handle.abort()` cleanly cancels the spawned crossterm reader on exit
  - `FnMut` closures in `run()` capture by `&mut` reference — captured vars accessible after run() returns
  - Initial `render()` called after `start()` in run() for good UX (show initial state before first event)
  - `Event<E>` derives `Debug` which requires `E: Debug` — practical constraint, all common types satisfy it
## Task self-review PASSED
---

## Iteration 2 - US-REVIEW-PHASE1: Review foundation (US-001 through US-008)
- What was done: Full review of all 6 source files across US-001 through US-008 (terminal.rs, utils.rs, component.rs, tui.rs, components/mod.rs, lib.rs). All 109 tests pass. Evaluated simplicity, correctness, edge cases, data structures, error handling. Performed cross-task analysis.
- Files changed: PRD.md (inserted fix task US-007a), progress.txt (this entry)

### Per-task findings:
- US-001 (scaffolding): PASS. Clean. One PRD [ ] for dev-dep image is correctly deferred to US-016.
- US-002 (Terminal trait): PASS. Minimal, object-safe. as_any pattern well documented.
- US-003 (ANSI utils): PASS. Correct CSI/OSC/APC handling. Good edge case coverage.
- US-004 (visible_width): PASS. Correct. Tab=3, grapheme-aware truncation, ANSI passthrough.
- US-005 (Component/Container): PASS. Minimal trait, clean composition. child_mut returns Box correctly.
- US-006 (TUI engine): PASS. Single buffer write, sync markers, reset suffixes. Event channel pattern clean.
- US-007 (Differential rendering): BUG FOUND — see below.
- US-008 (Async event loop): PASS. Clean select!, focus forwarding, quit handling.

### Bug found — cursor position on stop():
After differential rendering, hardware_cursor_row is set to last_changed + 1, which may be in the middle of content (not at cursor_row = lines.len()). When TUI::stop() is called (e.g., at end of run()), it delegates directly to terminal.stop() without repositioning the cursor. In the scrolling model, this means the shell prompt appears in the middle of the TUI's output.

Example: 5 lines, update line 1 only → hardware_cursor_row=2, cursor_row=5. After stop(), cursor is at row 2. Shell prompt overlays lines 2-4.

Fix inserted as US-007a: TUI::stop() must move cursor from hardware_cursor_row to cursor_row before calling terminal.stop().

### Cross-task analysis:
- Component trait: Ergonomic, not fighting ownership. Only render() required.
- Terminal trait: Minimal. Event reading outside trait works cleanly.
- Differential rendering math: Correct for all three paths. Only issue is stop() cursor.
- visible_width: Not yet needed in rendering engine (components pad their own output). Will be used by Text/Box.
- Async event loop: Channel closed handled. EventStream reader aborted on exit.
- Focus management: Clean integration. Index-based focus is pragmatic.
- TUI<E> generic: E: Send + 'static only. Components unaware of E. TUI<()> works.
- No duplication found across tasks.
- Naming/style consistent throughout.
- Data flows (Terminal→TUI→Container→Component, events→channels→select→handler) are clean and unidirectional.

### Review result: ISSUES FOUND (1 bug → US-007a fix task inserted)
- Learnings for future iterations:
  - Differential rendering leaving cursor mid-content is a common bug pattern — always verify cursor position at session boundaries (start/stop)
  - The hardware_cursor_row vs cursor_row distinction is critical and easy to miss
  - Test coverage should include stop-after-differential-render scenarios
---

## Iteration 3 - US-007a: Fix cursor repositioning on TUI stop
- What was done: Fixed TUI::stop() to emit `\x1b[{n}B` cursor-down escape before calling terminal.stop() when hardware_cursor_row < cursor_row. Added 2 tests: one verifying cursor movement after differential render (5 lines, update line 1, stop moves cursor down 3), one verifying no cursor movement when already at end. All 111 tests pass.
- Files changed: crates/tau-tui/src/tui.rs (stop() fix + 2 tests), PRD.md (criteria marked [x])
- Learnings for future iterations:
  - TDD worked cleanly: wrote 2 tests first, one failed, one passed (correct by accident since stop() was a no-op), then 3-line fix made both pass
  - stop() updates hardware_cursor_row after cursor move — keeps state consistent in case stop() is called multiple times (defensive)
  - The fix is write+flush, not buffered into sync markers — stop() is a one-time terminal teardown, not a render frame
## Task self-review PASSED
---

## Iteration 4 - US-REVIEW-PHASE1: Review foundation (re-review after US-007a fix)
- What was done: Re-reviewed all 6 source files (terminal.rs, utils.rs, component.rs, tui.rs, components/mod.rs, lib.rs) after US-007a cursor fix. All 111 tests pass. Zero clippy warnings. Verified US-007a fix is clean and correct. Full cross-task analysis passed.
- Files changed: PRD.md (review task marked [x]), progress.txt (this entry)

### Per-task re-evaluation (all PASS):
- US-001 (scaffolding): Clean workspace. image dev-dep deferred to US-016.
- US-002 (Terminal trait): Minimal 7-method trait + as_any for test downcasting.
- US-003 (ANSI utils): Correct CSI/OSC/APC parsing. 24 tests.
- US-004 (visible_width): Tab=3, grapheme-aware truncation, ANSI passthrough. 18 tests.
- US-005 (Component/Container): Minimal trait. child_mut returns &mut Box correctly. 11 tests.
- US-006 (TUI engine): Single-write rendering, sync markers, reset suffixes. 20 tests.
- US-007 (Differential rendering): All three paths verified by tracing. 13 tests.
- US-007a (stop cursor fix): Clean 3-line fix with 2 tests. Verified correct.
- US-008 (Async event loop): select!, focus forwarding, channel lifecycle. 9 async tests.

### Cross-task analysis (all clean):
- Component trait: ergonomic, only render() required. No fighting with Rust ownership.
- Terminal trait: minimal, event reading outside trait works cleanly via channels.
- Differential rendering math: traced all paths (first, width-change, differential, shrink, grow-from-empty, shrink-to-empty). Correct.
- visible_width: correctly deferred—not needed in engine yet, components pad their own output.
- Event loop: channel-closed handled (else => break), reader aborted on exit.
- Focus management: index-based, key forwarded before handler. Invalid index safely returns None.
- TUI<E>: E: Send + 'static only. Components unaware of E. TUI<()> works.
- No duplication between modules. Consistent naming/style. Clean unidirectional data flows.

## Phase 1 review PASSED
- Learnings for future iterations:
  - Iterative review works: first pass found a real bug, fix was clean, second pass confirmed everything is solid
  - The hardware_cursor_row/cursor_row distinction is the most subtle part of the codebase — well documented now
  - 111 tests provide strong coverage for the foundation layer
---

## Iteration 5 - US-009: Spacer component
- What was done: Implemented Spacer component in src/components/spacer.rs. Struct with `lines: usize` field, `new(lines)`, `set_lines(n)`, `Default` (1 line), Component impl returning `vec![String::new(); lines]`. Registered in components/mod.rs with `pub use`. 6 tests covering: n lines, default, zero, set_lines, width-independence, object safety. All 117 tests pass.
- Files changed: crates/tau-tui/src/components/spacer.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md (criteria marked [x])
- Learnings for future iterations:
  - Components in `components/` dir follow pattern: mod.rs declares `pub mod X; pub use X::Type;`
  - Spacer is the simplest possible component — good reference for the Component trait contract
  - `vec![String::new(); n]` is idiomatic Rust for n copies of an empty string
## Task self-review PASSED
---

## Iteration 6 - US-010: Text component with word wrapping
- What was done: Implemented `wrap_text_with_ansi()` in utils.rs and `Text` component in components/text.rs. wrap_text_with_ansi splits on word boundaries, breaks long words char-by-char (grapheme-aware), tracks ANSI SGR state and re-applies at start of each wrapped line, preserves hard newlines. Text component wraps content with configurable padding_x/padding_y, pads each line to full width, caches rendered output via RefCell<Option<CachedRender>>. 17 wrap tests + 15 Text tests added. All 149 tests pass.
- Files changed: crates/tau-tui/src/utils.rs (wrap_text_with_ansi + SGR helpers), crates/tau-tui/src/components/text.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - SGR tracking: accumulate all non-reset SGR codes in Vec<String>, \x1b[0m clears all. Redundant codes are harmless (terminal processes them in order).
  - Break-at-space tracking: record byte position in current_line string, break_width (visible width before space), and break_sgr (SGR state at space). after_break = current_line[bp+1..] naturally includes any ANSI codes after the space.
  - Final-line push logic: use `initial_len` to distinguish "empty hard line" (push empty) from "leftover after break" (don't push empty). Avoids spurious trailing empty lines.
  - RefCell<Option<CachedRender>> for caching in render(&self) — safe because Component doesn't require Send and TUI runs on single thread.
  - Text padding: left_pad + content + right_pad fills to full width. inner_width = width - 2*padding_x for wrapping.
  - Empty text or inner_width=0 → return empty vec (no padding lines either).
## Task self-review PASSED
---

## Iteration 7 - US-011: Box component
- What was done: Implemented BoxComponent in src/components/box_component.rs. Holds Vec<Box<dyn Component>> children with configurable padding_x, padding_y, and optional background color. Renders children at inner width (width - 2*padding_x), wraps each line with left padding + right padding to full width, applies background ANSI code if set (bg_start + content + bg_end), adds padding_y empty lines above and below. 12 tests covering: empty box, text child with padding, background on all lines, no-bg no-ANSI, inner width rendering, multiple children, remove/clear, invalidate propagation, object safety, empty children, padding_y only. All 161 tests pass.
- Files changed: crates/tau-tui/src/components/box_component.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - BoxComponent follows same container pattern as Container (add_child/remove_child/clear) but with render decoration
  - Background applied as bg_start + padded_line + \x1b[0m — reset at end of each line prevents bleed
  - When bg is None, bg_start="" and bg_end="" → no ANSI overhead in output
  - Empty children → empty result (no padding lines emitted), matching Text's "no content = no output" convention
  - `saturating_sub` for inner_width handles case where padding exceeds width
## Task self-review PASSED
---

## Iteration 8 - US-012: Input component
- What was done: Implemented Input component in src/components/input.rs. Single-line text input with "> " prompt, inverse-video cursor, full editing keybindings (insert, backspace, delete, word-delete, ctrl-u, ctrl-k), cursor movement (left, right, home, end, ctrl-left word-back, ctrl-right word-forward), horizontal scrolling via compute_scroll pure function, on_submit/on_escape callbacks, value()/set_value() API, focused flag. scroll_offset uses Cell<usize> for interior mutability in render(&self). 28 tests covering all editing ops, cursor movement, scrolling, callbacks, rendering. All 189 tests pass.
- Files changed: crates/tau-tui/src/components/input.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - Cell<usize> (not RefCell) is sufficient for scroll_offset since usize is Copy — simpler than RefCell
  - compute_scroll is a pure function: takes (cursor, current_offset, available) → new_offset. Separated from render logic for testability.
  - Scroll offset must be persisted between renders for smooth scrolling — without persistence, moving cursor left causes the view to jump back to start
  - render(&self) can't mutate fields directly — use Cell/RefCell for state that needs updating during render
  - Cursor operates on char indices, conversion to byte positions via char_to_byte helper
  - Word movement: skip spaces then skip word-chars (or vice versa) — simple two-phase algorithm
  - handle_input doesn't know the width, so scroll adjustment is deferred to render() which does know
  - \x1b[7m / \x1b[27m for inverse video cursor — 7m enables, 27m disables (not 0m which would reset everything)
  - Callbacks use `Option<Box<dyn FnMut>>` — clone the value before calling to avoid borrow issues
## Task self-review PASSED
---

## Iteration 9 - US-013: SelectList component
- What was done: Implemented SelectList component in src/components/select_list.rs. Selectable list with arrow-key navigation, wrapping, scrolling, filtering, and callbacks. SelectItem struct with value/label/description. Visible window rendering with "→ " prefix and bold/inverse styling for selected item. Scroll indicator "(N/M)" when list exceeds max_visible. set_filter() for case-insensitive prefix matching. 31 tests covering rendering, selection movement, wrapping, scrolling, filtering, callbacks, edge cases, object safety. All 220 tests pass.
- Files changed: crates/tau-tui/src/components/select_list.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md
- Learnings for future iterations:
  - SelectList uses `filtered_indices: Vec<usize>` as indirection layer — all selection/scroll operates on filtered indices, not raw items. Clean separation.
  - `selected` and `scroll_offset` are indices into filtered_indices, not into items — this makes filter changes simple (just reset both to 0).
  - Wrapping with modular arithmetic: `(selected + 1) % count` for down, `count - 1` for up-from-0.
  - `ensure_visible()` adjusts scroll_offset after each move — simple 2-condition check.
  - Bold+inverse combined: `\x1b[1;7m` for selected item — single SGR sequence with both attributes.
  - Selected line gets `\x1b[0m` at end (after padding) so background extends to full width. Unselected lines have no ANSI at all.
  - "(no items)" placeholder when filtered_indices is empty — consistent UX for empty states.
  - Scroll indicator right-aligned: pad with spaces before indicator text.
  - Callbacks clone the SelectItem before calling to avoid borrow issues with `&mut self` (same pattern as Input).
## Task self-review PASSED
---

## Iteration 10 - US-014: Overlay system
- What was done: Implemented overlay system with compositing, focus save/restore, and overlay stack. Added `Anchor` enum (Center, TopLeft, TopRight, BottomLeft, BottomRight), `OverlayOptions` struct (width, max_height, anchor, offset_x, offset_y), `OverlayHandle` (hide/set_hidden via `Rc<Cell<bool>>`), `OverlayEntry` (internal), and TUI methods (show_overlay, hide_overlay, has_overlay). Compositing happens in render() between base rendering and differential comparison — overlays are spliced into base lines at calculated positions. Added `slice_from_column` to utils.rs with SGR state tracking. Made `is_sgr`, `update_sgr_state`, `sgr_prefix` pub(crate). Modified run() key forwarding to check overlays first (topmost visible gets input). 32 new tests (8 slice_from_column, 5 splice, 4 position, 6 TUI methods, 3 compositing, 3 focus, 3 async input forwarding). All 252 tests pass.
- Files changed: crates/tau-tui/src/utils.rs (slice_from_column + SGR visibility), crates/tau-tui/src/tui.rs (overlay types + methods + compositing + tests), PRD.md
- Learnings for future iterations:
  - `Rc<Cell<bool>>` works well for shared visibility state in single-threaded TUI — TUI is already !Send due to Box<dyn Terminal>
  - Overlay compositing inserts between base rendering and differential comparison — differential rendering then naturally handles overlay changes
  - `splice_overlay_into_line` uses ANSI resets (\x1b[0m) as boundaries between base/overlay/base sections, and re-applies base SGR state for the "after" portion via `slice_from_column`
  - `truncate_to_width(s, col, "")` is the "slice before" operation — existing utility, no new code needed
  - `calculate_overlay_position` is a pure function with `saturating_sub` for all anchor types and `.max(0)` clamping for negative offsets
  - Base content is extended with empty strings if overlay position goes beyond — clean handling without special cases
  - Overlay stack uses Vec<OverlayEntry> with .pop() for LIFO ordering — topmost is last element, `iter_mut().rev()` for finding topmost visible
  - Focus save/restore: each overlay entry saves `self.focused` at show time, restores on hide — nested overlays work correctly
  - Key forwarding: overlays checked first via reverse iteration, falls through to focused component only if no visible overlays
## Task self-review PASSED
---

## Iteration 1 - US-REVIEW-PHASE2: Review components and overlays (US-009 through US-014)
- What was done: Full review of 7 source files across US-009 through US-014 (spacer.rs, text.rs, box_component.rs, input.rs, select_list.rs, tui.rs overlay system, utils.rs SGR/slice additions). All 252 tests pass. Zero clippy errors (6 warnings: 2 type_complexity, 4 repeat_n).

### Per-task findings:
- US-009 (Spacer): PASS. Trivially correct. 6 tests.
- US-010 (Text): PASS. Word wrapping with ANSI SGR tracking is correct. RefCell cache pattern appropriate. Padding_y lines are empty strings (intentional — vertical spacing only). 32 tests.
- US-011 (BoxComponent): PASS. Clean container pattern with bg color decoration. All lines padded to full width. Empty children → empty result. 12 tests.
- US-012 (Input): BUG FOUND — see below. Editing/keybindings/callbacks all correct. 28 tests (only ASCII).
- US-013 (SelectList): PASS. Clean filtered_indices indirection. All lines padded. Wrapping/scrolling correct. 31 tests.
- US-014 (Overlay): PASS. Compositing via splice_overlay_into_line is correct. SGR state tracking across splice boundaries works. Focus save/restore with nested overlays correct. Key forwarding to topmost visible overlay correct. 32 tests.

### Bug found — Input cursor math with wide characters (US-012):
Two related issues in `compute_scroll()` and render padding:

1. **compute_scroll() conflates char indices with column widths**: `available` is in columns (e.g., 8 for terminal width 10), but `cursor` and `offset` are char indices. With wide chars (2 cols each), scrolling by 1 char position only removes 2 columns but the algorithm treats it as removing 1 column-equivalent.

   Example: buffer = "你好世界测试编程代码" (10 chars, 20 cols), width=12, available=10.
   compute_scroll(cursor=10, offset=0, available=10): returns offset=1. But chars[1..10] = "好世界测试编程代码" = 18 visible columns in 10 available columns → massive overflow.

2. **Render padding uses char count instead of column width**: `content_width = PROMPT_WIDTH + vis_len.max(cursor_in_view + 1)` where `cursor_in_view + 1` counts chars, not columns. With cursor at end of "你好" (vis_len=4, cursor_in_view=2), content_width = 2+max(4,3) = 6, but actual visible content is 2+4+1=7 → padding is 1 column short → line overflows terminal width.

Fix inserted as US-012a: Input scroll and padding must operate consistently in column widths.

### Cross-task analysis:
- Component trait API: Consistent across all components. render(&self) works with interior mutability (RefCell/Cell) where needed.
- TUI<E> generic: Does NOT leak into Component trait. Components are E-agnostic. ✓
- Full-width padding: All components pad content lines to full width (Spacer uses empty strings for spacing, which is intentional). ✓
- Overlay compositing: splice handles wide chars at boundaries via truncate_to_width padding. ✓
- Overlay focus: save/restore with nested overlays tested and correct. ✓
- SelectList+overlay integration: Not explicitly tested but component model ensures it works — SelectList is a normal Component. ✓
- visible_width: Used correctly in Text, BoxComponent, Input, SelectList, overlay splice. ✓
- Duplicated padding patterns: Each component has slightly different padding logic (some have bg, some have left-pad). Not worth extracting a common helper.
- Clippy warnings: 6 total (4x repeat_n modernization in SelectList, 2x type_complexity for callback types). Style only, not correctness.

### Review result: ISSUES FOUND (1 bug → US-012a fix task inserted)
- Learnings for future iterations:
  - When a component tracks cursor position in char indices but renders in column widths, ALL math must be consistent. This is the same class of bug as hardware_cursor_row vs cursor_row in US-007.
  - Input scroll tests only use ASCII — wide char scroll tests would have caught this immediately.
  - The review criteria "Verify Input cursor math is correct with Unicode" is the right thing to check.
  - Overlay compositing is surprisingly correct with ANSI codes — the slice_from_column + splice pattern handles edge cases well through design (using resets as boundaries).
  - RefCell for caching in render(&self) is the standard pattern — all components that need it use it correctly.
---
