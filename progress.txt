# Progress Log

## Learnings
(Patterns discovered during implementation)

---

## Iteration 1 - US-001: Project scaffolding and dependencies
- What was done: Initialized Cargo lib project, set up all dependencies (crossterm with event-stream, unicode-width, unicode-segmentation, tokio, futures), created module structure with placeholder comments.
- Files changed: Cargo.toml, src/lib.rs, src/terminal.rs, src/utils.rs, src/component.rs, src/tui.rs, src/components/mod.rs
- Learnings for future iterations:
  - crossterm 0.28.1 resolved (0.29.0 available but PRD specifies 0.28)
  - unicode-segmentation resolved to 1.12.0 (compatible with specified 1.11)
  - All 56 dependency packages lock cleanly
  - cargo check and cargo test both pass with zero warnings
## Task self-review PASSED
---

## Iteration 2 - US-002: Terminal trait and CrosstermTerminal
- What was done: Implemented Terminal trait with 7 methods (start, stop, write, flush, size, hide_cursor, show_cursor), CrosstermTerminal using crossterm, and MockTerminal capturing writes to Vec<String>. Wrote 9 tests covering construction, writes, start/stop, cursor visibility, size, flush, and object safety.
- Files changed: src/terminal.rs, PRD.md
- Learnings for future iterations:
  - Terminal trait is object-safe — can use `Box<dyn Terminal>` (verified with test)
  - MockTerminal has public fields (writes, started, stopped, cursor_visible) for direct test assertions
  - MockTerminal.output() concatenates all writes for full output inspection
  - MockTerminal.set_size() allows simulating resize in tests
  - crossterm::terminal::size() may fail in test/CI environments — fallback to (80, 24)
  - Event reading is NOT on the trait — crossterm's EventStream used directly by TUI run loop
## Task self-review PASSED
---

## Iteration 3 - US-003: ANSI escape code utilities
- What was done: Verified existing implementation of strip_ansi and extract_ansi_code in src/utils.rs. All acceptance criteria already met — functions correctly handle CSI, OSC, and APC sequences. 24 tests covering normal paths, edge cases (unterminated sequences, bare ESC, out of bounds), and Unicode. Marked PRD criteria complete and committed.
- Files changed: PRD.md (acceptance criteria marked [x])
- Learnings for future iterations:
  - utils.rs already had full implementation from a prior session — always check existing code before writing new
  - extract_ansi_code works on byte offsets, not char offsets — callers must pass byte positions
  - OSC and APC share extract_string_sequence helper — both terminated by BEL or ST (ESC \)
  - CSI parsing follows ECMA-48: param bytes (0x30-0x3F), intermediate bytes (0x20-0x2F), final byte (0x40-0x7E)
  - strip_ansi delegates to extract_ansi_code for consistent parsing
## Task self-review PASSED
---

## Iteration 4 - US-004: Visible width calculation
- What was done: Implemented `visible_width()` and `truncate_to_width()` in src/utils.rs. Added 18 new tests covering ASCII, ANSI, wide chars, tabs, truncation with ellipsis, ANSI preservation, wide char truncation, edge cases (empty string, max_width < ellipsis width, empty ellipsis).
- Files changed: src/utils.rs, PRD.md
- Learnings for future iterations:
  - `visible_width` strips ANSI first via `strip_ansi`, then sums per-char widths with `UnicodeWidthStr::width` on 1-char slices
  - `truncate_to_width` walks bytes manually, passing through ANSI codes and counting grapheme widths — this pattern (byte-walking with ANSI passthrough) will recur in `wrap_text_with_ansi` (US-010)
  - Tab = 3 spaces convention from pi-mono
  - `unicode_segmentation::UnicodeSegmentation` used for grapheme-aware truncation
  - `saturating_sub` handles edge case where ellipsis is wider than max_width
## Task self-review PASSED
---

## Iteration 5 - US-005: Component trait and Container
- What was done: Implemented `Component` trait (render required, handle_input + invalidate with defaults) and `Container` struct (Vec<Box<dyn Component>>, add_child, remove_child, clear, render concatenation, invalidate propagation). Wrote 11 tests including empty container, concatenation, remove/clear, default/len/is_empty, invalidation, empty child, trait defaults, and object safety.
- Files changed: src/component.rs, PRD.md
- Learnings for future iterations:
  - Component trait is object-safe — `Box<dyn Component>` works (verified with test)
  - Container.render() simply extends a Vec from each child — no special casing needed
  - Can't inspect trait object internals through Box<dyn Component> (e.g., can't check MockComponent.invalidated) — design tests around observable behavior instead
  - `Default` impl provided for Container (Clippy will want this if `new()` exists)
  - Container also exposes `len()` and `is_empty()` for convenience
## Task self-review PASSED
---

## Iteration 6 - US-006: TUI engine with full rendering
- What was done: Implemented `TUI<E>` struct generic over user event type with full rendering to terminal. Added `as_any()`/`as_any_mut()` to Terminal trait for test downcasting. TUI wraps `Box<dyn Terminal>` and root `Container`, provides `new()`, `root()`, `start()`, `stop()`, `render()`, `event_tx()`. Render builds a single String buffer wrapped in synchronized output markers, appends `\x1b[0m` reset to each line, writes+flushes once. Stores `previous_lines` and `previous_width` for future differential rendering. 20 new tests covering construction, start/stop, rendering (empty, single/multi-line, ANSI preservation, width tracking), event channel, integration.
- Files changed: src/tui.rs (full implementation), src/terminal.rs (added as_any/as_any_mut to Terminal trait + both impls), PRD.md
- Learnings for future iterations:
  - Standard Rust pattern for trait-object downcasting: add `as_any(&self) -> &dyn Any` to trait, impl returns `self`
  - `tokio::sync::mpsc::unbounded_channel()` can be created without a tokio runtime; only recv() needs async context
  - Each line gets `\x1b[0m\r\n` suffix — cursor ends on fresh line after last content, simplifying cursor math for differential rendering in US-007
  - Empty render produces just sync markers `\x1b[?2026h\x1b[?2026l` — no special casing needed
  - `event_rx` stored as `Option<UnboundedReceiver<E>>` so US-008's run loop can `.take()` it
  - MockTerminal.writes has exactly 1 entry per render() call — verified by tests
## Task self-review PASSED
---

## Iteration 7 - US-007: Differential rendering
- What was done: Rewrote TUI::render() to support differential rendering. Three render paths: first render (previous_width==0, writes all lines without clearing), width changed (clear screen + full redraw), differential (compare previous_lines vs new, only rewrite changed lines). Added `cursor_row` and `hardware_cursor_row` fields to TUI struct. When no changes detected, no output is written at all. Content shrink handled by clearing old lines with `\x1b[2K\r\n` and cursor-up to return. Updated 2 existing tests and added 13 new differential rendering tests. All 95 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, PRD.md, AGENTS.md
- Learnings for future iterations:
  - `previous_width == 0` serves as "never rendered" sentinel — no separate flag needed
  - `hardware_cursor_row` is critical for cursor math — after a partial update it may differ from `cursor_row`
  - Unified loop from `first_changed..=last_changed` handles grow/shrink/change naturally — no separate steps
  - `\x1b[2K` clears entire line but doesn't move cursor — `\r` before content ensures column 0
  - `\x1b[nA`/`\x1b[nB` with n=0 is treated as n=1 by terminals — only emit when diff > 0
  - Empty first render produces no output (not even sync markers) — cleaner than US-006's approach
  - `use std::fmt::Write` enables `write!(buffer, ...)` for formatting into String efficiently
  - Project is now a workspace: TUI code in crates/tau-tui/, tests via `cargo test -p tau-tui`
## Task self-review PASSED
---

## Iteration 8 - US-008: Async event loop with user events
- What was done: Implemented `Event<E>` enum (Key, Resize, User), `quit()`, focus management (`set_focus`/`focused`), and `TUI::run()` async event loop. Added `child_mut()` to Container for focus key forwarding. Added `crossterm_event_tx()` for injecting terminal events (testability). The run loop spawns a crossterm EventStream reader task, then `tokio::select!` on crossterm_rx and user_rx channels. Key events auto-forwarded to focused component before handler. Wrote 9 new tests (async with `#[tokio::test]`). All 109 tests pass.
- Files changed: crates/tau-tui/src/tui.rs, crates/tau-tui/src/component.rs, PRD.md
- Learnings for future iterations:
  - crossterm `KeyCode::Esc` not `KeyCode::Escape` — always check crossterm API names
  - `Container::child_mut()` returns `Option<&mut Box<dyn Component>>` not `Option<&mut dyn Component>` — returning the inner dyn ref causes lifetime issues with `'static` trait objects
  - Crossterm EventStream works fine in tests (no real terminal): spawned reader task just blocks on stdin, test events injected via crossterm_tx channel
  - `run()` uses `.take()` on Option receivers (consumed once) — calling run() twice panics with clear message
  - `reader_handle.abort()` cleanly cancels the spawned crossterm reader on exit
  - `FnMut` closures in `run()` capture by `&mut` reference — captured vars accessible after run() returns
  - Initial `render()` called after `start()` in run() for good UX (show initial state before first event)
  - `Event<E>` derives `Debug` which requires `E: Debug` — practical constraint, all common types satisfy it
## Task self-review PASSED
---

## Iteration 2 - US-REVIEW-PHASE1: Review foundation (US-001 through US-008)
- What was done: Full review of all 6 source files across US-001 through US-008 (terminal.rs, utils.rs, component.rs, tui.rs, components/mod.rs, lib.rs). All 109 tests pass. Evaluated simplicity, correctness, edge cases, data structures, error handling. Performed cross-task analysis.
- Files changed: PRD.md (inserted fix task US-007a), progress.txt (this entry)

### Per-task findings:
- US-001 (scaffolding): PASS. Clean. One PRD [ ] for dev-dep image is correctly deferred to US-016.
- US-002 (Terminal trait): PASS. Minimal, object-safe. as_any pattern well documented.
- US-003 (ANSI utils): PASS. Correct CSI/OSC/APC handling. Good edge case coverage.
- US-004 (visible_width): PASS. Correct. Tab=3, grapheme-aware truncation, ANSI passthrough.
- US-005 (Component/Container): PASS. Minimal trait, clean composition. child_mut returns Box correctly.
- US-006 (TUI engine): PASS. Single buffer write, sync markers, reset suffixes. Event channel pattern clean.
- US-007 (Differential rendering): BUG FOUND — see below.
- US-008 (Async event loop): PASS. Clean select!, focus forwarding, quit handling.

### Bug found — cursor position on stop():
After differential rendering, hardware_cursor_row is set to last_changed + 1, which may be in the middle of content (not at cursor_row = lines.len()). When TUI::stop() is called (e.g., at end of run()), it delegates directly to terminal.stop() without repositioning the cursor. In the scrolling model, this means the shell prompt appears in the middle of the TUI's output.

Example: 5 lines, update line 1 only → hardware_cursor_row=2, cursor_row=5. After stop(), cursor is at row 2. Shell prompt overlays lines 2-4.

Fix inserted as US-007a: TUI::stop() must move cursor from hardware_cursor_row to cursor_row before calling terminal.stop().

### Cross-task analysis:
- Component trait: Ergonomic, not fighting ownership. Only render() required.
- Terminal trait: Minimal. Event reading outside trait works cleanly.
- Differential rendering math: Correct for all three paths. Only issue is stop() cursor.
- visible_width: Not yet needed in rendering engine (components pad their own output). Will be used by Text/Box.
- Async event loop: Channel closed handled. EventStream reader aborted on exit.
- Focus management: Clean integration. Index-based focus is pragmatic.
- TUI<E> generic: E: Send + 'static only. Components unaware of E. TUI<()> works.
- No duplication found across tasks.
- Naming/style consistent throughout.
- Data flows (Terminal→TUI→Container→Component, events→channels→select→handler) are clean and unidirectional.

### Review result: ISSUES FOUND (1 bug → US-007a fix task inserted)
- Learnings for future iterations:
  - Differential rendering leaving cursor mid-content is a common bug pattern — always verify cursor position at session boundaries (start/stop)
  - The hardware_cursor_row vs cursor_row distinction is critical and easy to miss
  - Test coverage should include stop-after-differential-render scenarios
---

## Iteration 3 - US-007a: Fix cursor repositioning on TUI stop
- What was done: Fixed TUI::stop() to emit `\x1b[{n}B` cursor-down escape before calling terminal.stop() when hardware_cursor_row < cursor_row. Added 2 tests: one verifying cursor movement after differential render (5 lines, update line 1, stop moves cursor down 3), one verifying no cursor movement when already at end. All 111 tests pass.
- Files changed: crates/tau-tui/src/tui.rs (stop() fix + 2 tests), PRD.md (criteria marked [x])
- Learnings for future iterations:
  - TDD worked cleanly: wrote 2 tests first, one failed, one passed (correct by accident since stop() was a no-op), then 3-line fix made both pass
  - stop() updates hardware_cursor_row after cursor move — keeps state consistent in case stop() is called multiple times (defensive)
  - The fix is write+flush, not buffered into sync markers — stop() is a one-time terminal teardown, not a render frame
## Task self-review PASSED
---

## Iteration 4 - US-REVIEW-PHASE1: Review foundation (re-review after US-007a fix)
- What was done: Re-reviewed all 6 source files (terminal.rs, utils.rs, component.rs, tui.rs, components/mod.rs, lib.rs) after US-007a cursor fix. All 111 tests pass. Zero clippy warnings. Verified US-007a fix is clean and correct. Full cross-task analysis passed.
- Files changed: PRD.md (review task marked [x]), progress.txt (this entry)

### Per-task re-evaluation (all PASS):
- US-001 (scaffolding): Clean workspace. image dev-dep deferred to US-016.
- US-002 (Terminal trait): Minimal 7-method trait + as_any for test downcasting.
- US-003 (ANSI utils): Correct CSI/OSC/APC parsing. 24 tests.
- US-004 (visible_width): Tab=3, grapheme-aware truncation, ANSI passthrough. 18 tests.
- US-005 (Component/Container): Minimal trait. child_mut returns &mut Box correctly. 11 tests.
- US-006 (TUI engine): Single-write rendering, sync markers, reset suffixes. 20 tests.
- US-007 (Differential rendering): All three paths verified by tracing. 13 tests.
- US-007a (stop cursor fix): Clean 3-line fix with 2 tests. Verified correct.
- US-008 (Async event loop): select!, focus forwarding, channel lifecycle. 9 async tests.

### Cross-task analysis (all clean):
- Component trait: ergonomic, only render() required. No fighting with Rust ownership.
- Terminal trait: minimal, event reading outside trait works cleanly via channels.
- Differential rendering math: traced all paths (first, width-change, differential, shrink, grow-from-empty, shrink-to-empty). Correct.
- visible_width: correctly deferred—not needed in engine yet, components pad their own output.
- Event loop: channel-closed handled (else => break), reader aborted on exit.
- Focus management: index-based, key forwarded before handler. Invalid index safely returns None.
- TUI<E>: E: Send + 'static only. Components unaware of E. TUI<()> works.
- No duplication between modules. Consistent naming/style. Clean unidirectional data flows.

## Phase 1 review PASSED
- Learnings for future iterations:
  - Iterative review works: first pass found a real bug, fix was clean, second pass confirmed everything is solid
  - The hardware_cursor_row/cursor_row distinction is the most subtle part of the codebase — well documented now
  - 111 tests provide strong coverage for the foundation layer
---

## Iteration 5 - US-009: Spacer component
- What was done: Implemented Spacer component in src/components/spacer.rs. Struct with `lines: usize` field, `new(lines)`, `set_lines(n)`, `Default` (1 line), Component impl returning `vec![String::new(); lines]`. Registered in components/mod.rs with `pub use`. 6 tests covering: n lines, default, zero, set_lines, width-independence, object safety. All 117 tests pass.
- Files changed: crates/tau-tui/src/components/spacer.rs (new), crates/tau-tui/src/components/mod.rs (module registration), PRD.md (criteria marked [x])
- Learnings for future iterations:
  - Components in `components/` dir follow pattern: mod.rs declares `pub mod X; pub use X::Type;`
  - Spacer is the simplest possible component — good reference for the Component trait contract
  - `vec![String::new(); n]` is idiomatic Rust for n copies of an empty string
## Task self-review PASSED
---
